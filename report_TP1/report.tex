\documentclass[a4paper,11pt]{article}
\usepackage[francais]{babel}
%% Prévu pour compiler avec lualatex
% \usepackage[utf8]{inputenc}
\usepackage{fontspec}
\usepackage{libertine}
% \usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage[top=2.5cm, bottom=2.5cm, left=2cm, right=2cm]{geometry}
\usepackage{listings}
\usepackage[utf8]{luainputenc}
\usepackage[hidelinks]{hyperref}
\usepackage{caption}

\lfoot{\bsc{Enseirb-Matmeca}}
\rfoot{Informatique --- 3\ieme{} année}

\pagestyle{fancy}
\begin{document}

\begin{titlepage}
  \begin{center}

    \begin{center}
      \includegraphics[width=4cm]{EM.jpg}
    \end{center}

    \vspace*{1cm}
        
    \rule{0.75\linewidth}{0.7mm}\\[0.4cm]
    {\Huge Rapport TP1 --- PVM\\[0.4cm]}
    \rule{0.75\linewidth}{0.7mm} \\[1.5cm]

    {\Large Bazire Houssin\\Sylvain Vaglica\\Stéphane \bsc{Castelli}\\[2cm]}
    {\Large Mardi 29 Octobre 2013}
  \end{center}
\end{titlepage}

\tableofcontents
\clearpage
\section{Introduction}

PVM est une bibliothèque C et Fortran permettant la communication entre des processus sur une machine parallèle ou un cluster de machines ; elle utilise pour cela un démon lancé sur chaque machine qui se charge du routage des messages, du contrôle des processus et des problèmes pouvant survenir.Créée en 1989, PVM a au fil des décennies perdu en popularité au profit de MPI, mais reste un moyen efficace d'apporter une solution à des problèmes dont la résolution en séquentiel mettrait trop de temps. Au travers de ce projet, il a été réalisé un système distribué de craquage de mot de passe en force brute, sur le modèle maître / esclaves, avec un processus maître créant et distribuant des tâches, et des processus esclaves les exécutant. Un des objectifs principaux du projet, en plus de nous initier à la communication inter-processus et plus particulièrement à PVM, est d'analyser et optimiser la création et la répartition des tâches afin d'obtenir les meilleures performances possibles. Il sera d'abord explicité les choix qui ont été effectués, puis ils seront analysés.

\section{Réprésentation des données}

%gmp
%type de données transmis
%conversion entier/mdp


\section{Le maître}
Il s'occupe de démarrer les processus esclaves et de leur assigner les tâches. Le processus maître commence par envoyer à chaque esclave le mot de passe en clair, puis transforme l'ensemble des mots de passe possibles en un intervalle d'entiers (fonction bijective décrite dans la partie précédente). Chaque fois qu'un esclave demande du travail, il lui assigne un sous intervalle de l'intervalle initial, en lui donnant le début de l'intervalle et un pas (nombres d'entiers à tester).
Une gestion dynamique du pas est essentielle pour équilibrer le travail des esclaves et garantir une exécution la plus rapide possible. En effet, il est essentiel que l'ensemble des esclaves terminent le plus proche possible les un des autres.

\section{Les esclaves}
Chacun reçoit quand il le demande, un intervalle d'entiers correspondant à un certain nombre de mot de passe possibles à tester.
En effet, pour chaque entier de l'intervalle, l'esclave le convertit en une chaine de caractère et le compare ensuite grâce à la fonction \texttt{strcmp()} , au mot de passe réel reçu en argument lors de la création des processus esclaves par le maître. Si le résultat est positif, l'esclave communique au maître que l'exécution doit terminer car le mot de passe a été trouvé. Sinon, il continue jusqu'à arriver à la fin de son intervalle. Il communique alors avec le processus maître pour recevoir un nouvel intervalle de travail.


\section{La répartition des tâches}
% choix des intervalles
% demande de travail des esclaves
% attribution


\section{Changements en version multi-threadée}
Les changements en version multi-threadés sont beaucoup plus importants sur l'esclave que sur le maître.

En effet, pour le maître, les changements sont quasi-inexistants : mis à part les changements sur les arguments à donner aux esclaves, et quelques modifications mineures comme le renvoi d'un message en cas de famine (toutes les données consommées), rien d'autres ne change.

En revanche, pour le fils les modifications sont importantes : il subdivise à nouveau l'intervalle reçu (par exemple en fonction de la longueur du mot de passe et du nombre de threads, afin de limiter la famine de données), et fait tester ces morceaux par des threads indépendants.
Chacun de ses threads effectue les tests et incrémente sur son intervalle, comme dans la version précedente. 
Cependant, si un des threads, en piochant des données, réalise que la moitié des données ont été consommées et qu'il n'y en a pas "en réserve", il exécute le thread de communication avec le maître, pour demander de nouvelles données, stockées dans des variables.
Aussi, si un thread réalise que les données courantes sont vides, il va les remplacer par le nouvel intervalle en réserve, ou terminer si la réserve est vide.


Il est important d'appliquer un verrous sur les données suivantes, afin d'éviter des lectures/écritures concurrentes :
\begin{itemize}
\item la condition de fin 
\item l'intervalle de travail actuel
\item le thread de communication avec le maître (PVM n'est pas "thread-safe", donc un seul à la fois)
\item la variable permettant de savoir si il y a des donnees en réserve, ou si au moins elles ont été demandées.
\end{itemize}
De même, le coût de prise de ces verrous (\texttt{pthread_mutex_t}) est élevé, il est donc important de minimiser le nombre de prise, en effectuant des lectures en deux temps dans le cas de conditionnelles par exemple :
le test est effectué une première fois sans le verrou, si le test est positif, le verrou sur la variable est pris, le test est effectué à nouveau, le code correspondant est effectué, et la variable déverrouillée.

En pratique, dans notre implémentation nous rencontrons des problèmes (erreurs de segmentation au niveau de l'esclave),que nous pensons dû à des appels de fonctions pvm (en particulier pvm_initsend(PvmDataDefault)), en particulier quand les échanges de données ne sont pas totalement recouvert (c'est-à-dire quand le mot de passe est petit, et que les processus et threads sont très nombreux).
Ainsi des exécutions comme \texttt{./craquage_multithread 1 1 6 p}, ou \texttt{./craquage_multithread 2 2 9 p} fonctionne parfaitement (entre autres, de nombreuses autres fonctionnent), de même que lorsque l'on remplace p par un mot de passe possible à trouver.


Enfin, sur les exécutions réussies, nous avons observé que les performances étaient décevantes : bien que les échanges de données soient totalement recouverts par les calculs, il semblerait que les prises de verrous ralentissent considérablement l'exécution, pour un résultat plus lent que celui de la version précédente.
Cependant, peut être est-ce simplement parce que nous avons cherché à résoudre les problèmes ci-dessous, et que nous n'avons pas évalué suffisamment de configuration (nombre de processus, nombre de threads, taille du pas...).
\section{Performances}
\begin{figure}[h!]
  \centering
  \includegraphics[width=\textwidth]{plot.png}
  \caption{Tests de performance}
  \label{perf}
\end{figure}
\section{Conclusion}




\end{document}
